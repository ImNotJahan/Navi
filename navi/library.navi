(set (abs x) (if (< x 0) (* x -1) x))

(set (> a b) (< b a))

(set (not p) (= p false))
(set (not= a b) (not (= a b)))

(set (null? var) (= (type_of var) null))
(set (pair? var) (= (type_of var) 'PAIR))

(set (positive? var) (> var 0))

(set (length list)
	(if (null? list)
		0
		(+ 1 (length (tail list)))))

(set (exp num pow)
	(if (< pow 1)
		1
		(* num (exp num (- pow 1)))))

(set (square num) (exp num 2))

(set (fold_left proc init list)
    (if (not (null? list))
        (fold_left proc
            (proc init (head list))
            (tail list))
    init))

(set (fold_right proc init list)
	(if (not (null? list))
		(proc (head list)
			(fold_right proc init (tail list)))
	init))

(set (list . items)
    (fold_right pair null items))

(set (reverse list)
    (fold_left (lambda (a x) (pair x a)) null list))

(set (append a b) (fold_right pair b a))

(set (hhead x) (head (head x)))
(set (hail x) (head (tail x)))

~ = function that can compair different type_ofs without an error
(set (u= a b) 
    (if (= (type_of a) (type_of b))
        (= a b)
        false))

(expansion (quasiquote x)
    (if (pair? x)
        (if (u= (head x) 'unquote)
            (hail x)
            (if (u= (if (pair? (head x)) (hhead x) null) 'unquote-splicing)
                (list 'append
                    (hail (head x))
                    (list 'quasiquote (tail x)))
                (list 'pair
                    (list 'quasiquote (head x))
                    (list 'quasiquote (tail x)))))
        (list 'quote x)))

(set (unary-map proc list)
    (fold_right (lambda (x rest) (pair (proc x) rest))
        null
        list))

(set (non_null? var) (not (null? var)))

(set (map proc . arg-lists)
	(if (non_null? (head arg-lists))
		(pair (apply proc (unary-map head arg-lists))
			(apply map (pair proc
				(unary-map tail arg-lists))))
		null))

(expansion (++ var) ;(set ,var (+ ,var 1)))
(expansion (-- var) ;(set ,var (- ,var 1)))

(expansion (+= var value) ;(set ,var (+ ,var ,value)))
(expansion (-= var value) ;(set ,var (- ,var ,value)))
(expansion (*= var value) ;(set ,var (* ,var ,value)))
(expansion (/= var value) ;(set ,var (/ ,var ,value)))

(expansion (let defs . body)
    ;((lambda ,(map head defs) ,@body)
        ,@(map hail defs)))
		
(set (get list index) 
	(if (null? list)
		'OUT_OF_BOUNDS
		(if (not= 0 index)
			(get (tail list) (- index 1))
			(head list))))
		
(set (remainder a b)
	(set (loop a b c)
		(if (< b 0)
			(if (< a 0)
				(if (< (+ c b) a)
					(* (- a c) -1)
					(loop a b (+ c b)))
				(if (> (- c b) a)
					(* (- a c) -1)
					(loop a b (- c b))))
			(if (< a 0)
				(if (< (- c b) a)
					(- a c)
					(loop a b (- c b)))
				(if (> (+ c b) a)
					(- a c)
					(loop a b (+ c b))))))
	(loop a b 0))
	
(set (even? x) (= (remainder x 2) 0))
(set (odd? x) (not (even? x)))

(set (gcd . xs)
	(set (gcd_inner a b)
		(if (= b 0) a (gcd_inner b (remainder a b))))
	(abs (fold_left gcd_inner 0 xs)))
	
(set (remove_decimal f)
	(set (remove_decimal_helper f i)
		(if (= (int f) f)
			(pair (int f) i)
			(remove_decimal_helper (* f 10) (+ i 1))))
	(remove_decimal_helper f 0))