(set (> a b) (< b a))
(set (<= a b) (or (< a b) (= a b)))
(set (>= a b) (or (> a b) (= a b)))

(set (not p) (= p false))
(set (not= a b) (not (= a b)))

(set (null? var) (= (type_of var) null))
(set (pair? var) (= (type_of var) 'PAIR))

(set (positive? var) (> var 0))

(set (length list)
	(if (null? list)
		0
		(+ 1 (length (tail list)))))

(set (fold_left proc init list)
    (if (not (null? list))
        (fold_left proc
            (proc init (head list))
            (tail list))
    init))

(set (fold_right proc init list)
	(if (not (null? list))
		(proc (head list)
			(fold_right proc init (tail list)))
	init))

(set (list . items)
    (fold_right pair null items))

(set (reverse list)
    (fold_left (lambda (a x) (pair x a)) null list))

(set (append a b) (fold_right pair b a))

(set (hhead x) (head (head x)))
(set (hail x) (head (tail x)))

~ = function that can compare different type_ofs without an error
(set (u= a b) 
    (if (= (type_of a) (type_of b))
        (= a b)
        false))

(expand (quasiquote x)
    (if (pair? x)
        (if (u= (head x) 'unquote)
            (hail x)
            (if (u= (if (pair? (head x)) (hhead x) null) 'unquote-splicing)
                (list 'append
                    (hail (head x))
                    (list 'quasiquote (tail x)))
                (list 'pair
                    (list 'quasiquote (head x))
                    (list 'quasiquote (tail x)))))
        (list 'quote x)))

(set (unary-map proc list)
    (fold_right (lambda (x rest) (pair (proc x) rest))
        null
        list))

(set (non_null? var) (not (null? var)))

(set (map proc . arg-lists)
	(if (non_null? (head arg-lists))
		(pair (apply proc (unary-map head arg-lists))
			(apply map (pair proc
				(unary-map tail arg-lists))))
		null))

(expand (++ var) ;(set ,var (+ ,var 1)))
(expand (-- var) ;(set ,var (- ,var 1)))

(expand (+= var value) ;(set ,var (+ ,var ,value)))
(expand (-= var value) ;(set ,var (- ,var ,value)))
(expand (*= var value) ;(set ,var (* ,var ,value)))
(expand (/= var value) ;(set ,var (/ ,var ,value)))

(expand (let defs . body)
    ;((lambda ,(map head defs) ,@body)
        ,@(map hail defs)))
		
(set (get list index) 
	(if (null? list)
		'OUT_OF_BOUNDS
		(if (not= 0 index)
			(get (tail list) (- index 1))
			(head list))))

(set (in x list)
	(if (null? list)
		false
		(if (u= (head list) x)
			true
			(in x (tail list)))))
	
(set (even? x) (= (remainder x 2) 0))
(set (odd? x) (not (even? x)))
	
(set (count n) (if (= n 0) 0 (+ 1 (count (- n 1)))))

(set (break) (error "EMPTY"))

(expand (do . body)
	;((lambda () ,@body)))

(expand (when p . body)
	;(if ,p (do ,@body) null))
	
(set (newline) (say #\n))